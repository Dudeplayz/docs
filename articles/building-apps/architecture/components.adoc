---
title: System Components
description: TODO WRITE THE DESCRIPTION
order: 20
---

# System Components

In the <<design, Designing the Architecture>> page of the documentation, you learned about _system components_ and _UI components_. On this page, you are going to learn more about system components and how to turn them into Java code.

Vaadin applications are composed from system components, at least one of which is the user interface. The number of system components depends on the size and complexity of the application. A small application could have only one component, a large application tens of components. Here is an example of a Vaadin app with three components:

image:images/three-components.png[A diagram of three system components and a database]

Here, the _Views_ component talks to the _Services_ component. The _Services_ component in turn talks to the _Entities_ component, which uses JPA to communicate with a relational database.

## Components in Java

The Java programming language has no component concept. Instead, you use Java packages to model components. Thus, the component diagram above would correspond to the following Java package structure:

* `com.example.application` - root package that contains the Spring Boot application class.
* `com.example.application.views` - package corresponding to the _views_ system component.
* `com.example.application.services` - package corresponding to the _services_ system component.
* `com.example.application.entities` - package corresponding to the _entities_ system component.

For small system components, a package per component is enough. However, in more complex cases, you need to create subpackages to keep the code organized. You may also need to organize the system component packages themselves into parent packages. For more information about this, please see the <<{articles}/building-apps/project-structure,Project Structure>> section of the documentation.

## Component APIs

A system component can have an _Application Programming Interface_ (API) that allows other components to _call_ it. We say _can have_, because system components are not required to make themselves available to other components. For instance, a user interface system component will typically only be called by the web browser and never by other system components. It therefore does not need an API at all.

In Java, the API consist of all _public_ classes, interfaces and methods inside the system component package. In other words, the simplest possible component with an API is a package, that contains a single public Java class, that in turn contains a single public method.

All classes or methods that are not considered a part of the API should have a diffrerent visibility than public, such as package private.

A system component can inherit the API of another component that it depends on. For instance, in the example above, the services component can inherit the API of the entities component, like this:

.OrderService.java
[source,java]
----
package com.example.application.services;

import com.example.application.entities.OrderRepository;
import com.example.application.entities.DraftOrder;
import com.example.application.entities.CompletedOrder;

import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
public class OrderService { // <1>

    private final OrderRepository repository;

    OrderService(OrderRepository repository) { // <2>
        this.repository = repository;
    }

    @Transactional
    public CompletedOrder completeOrder(DraftOrder draftOrder) { // <3>
        var completedOrder = draftOrder.complete();
        return repository.save(completedOrder);
    }
}
----
<1> `OrderService` is a part of the API, so it is _public_.
<2> The services system component takes care of instantiating the service itself. The constructor is _package private_, as it is not part of the API.
<3> `completeOrder` is a part of the API, so it is _public_. `DraftOrder` and `CompletedOrder` are inherited from the API of the entities system component.

As you can see, you are not required to use Java interfaces for the API unless you need or want to.

## Component SPIs

A system component can also have a _Service Provider Interface_ (SPI) that allows other components to _plug into_ it. This is especially useful in cases where a component needs to interact with an external system, or when a component needs to externalize some business rules to another component, for example because they are so complex or change often.

An SPI is an interface that one component _declares_, and another component _implements_ (in other words, the adapter design pattern). In Java, it consists of at least one Java interface and optionally other types that the interface needs. For example, if the interface needs a Java class or a Java record as an input argument or return value, this would be a part of the SPI as well. An SPI is also allowed to include types from the system component's API.

For instance, in the example above, the services system component may need to integrate with an external system. Instead of putting all the code inside a single component, the services components declares an SPI. Then, a new system integration component is created that implements this SPI and handles the actual interaction with the external system:

image:images/components-with-spi.png[A diagram of four system components, an external system and a database]

This not only separates the concerns, but also protects the application from changes in the external system. If the external system's API changes, you only need to fix the system integration component. The rest of the system components can remain unchanged.

To distinguish between API and SPI classes interface, we recommend that the SPI classes and interfaces are put inside their own subpackage called `spi`. In the example above, the SPI could look like this:

.ShippingSystem.java
[source,java]
----
package com.example.application.services.spi; // <1>

import com.example.application.entities.CompletedOrder;

public interface ShippingSystem {

    void shipCompletedOrder(CompletedOrder completedOrder); // <2>
}
----
<1> The interface is in the `spi` subpackage to make it clear that it is intended to be implemented by another system component.
<2> The `CompletedOrder` class, which is inherited from the API of the entities system component, can also be used by the SPI.

There are also cases where an interface can act as both the API and the SPI of the component at the same time. A typical example of this is the repository interface of a domain model component:

image:images/combined-spi-api.png[A diagram of three system components: Services, Domain Model and Persistence]

The repository interface is a part of the API of the domain model and called by the services system component. However, the repository interface is also a part of the SPI of the domain model and implemented by the persistence system component (that in turn talks to the database). In this case, using a subpackage `spi` is only confusing. Instead, JavaDocs or custom annotations (like `@API` or `@SPI`) should be used to explain the roles of the interface. Sometimes you just have to be pragmatic.

## Instantiating Components

As Java has no component concept, a component instance consists of ordinary Java objects during runtime. These objects are instantiated by Spring, which also takes care of setting up the dependencies between them through dependency injection. We recommend using _constructor injection_ into _final_ fields, rather then autowiring into mutable fields, like this:

.InvoiceGenerationService.java
[source,java]
----
@Service
public class InvoiceGenerationService {
    
    private final InvoiceRepository invoiceRepository;
    private final AccountingSystem accountingSystem;
    private final ApplicationEventPublisher eventPublisher;

    InvoiceGenerationService(InvoiceRepository invoiceRepository,
                             AccountingSystem accountingSystem,
                             ApplicationEventPublisher eventPublisher) {
        this.invoiceRepository = invoiceRepository;
        this.accountingSystem = accountingSystem;
        this.eventPublisher = eventPublisher;
    }
}
----

There are three reasons for this recommendation: it becomes immediately clear what the dependencies of the class are, it is impossible to even instantiate the class without the necessary dependencies, and it is impossible to accidentally modify the dependencies after instantiation. If the number of constructor arguments grows too big, the class has too many responsibilities and needs to be split up into smaller parts.

In most cases, using Spring's component scanning and stereotype annotations (`@Component`, `@Service`, etc.) is enough to instantiate all the objects in your system component, regardless of whether they are public or package private. However, if you need more finegrained control over the object creation, you can utilize Spring's Java-based container configuration. Inside your component, create a `@Configuration`-annotated class and use `@Bean`-methods to create the objects.

Unless you need to `@Import` the configuration class into some other configuration class, you can make it package private to make it clear that it is not considered a part of the system component's API.

If you are not familiar with Spring's Java-based container configuration, or you want to learn more about it, please read the https://docs.spring.io/spring-framework/reference/core/beans/java/basic-concepts.html:[Spring Framework Documentation].

