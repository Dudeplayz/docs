---
title: Microservices
description: Learn how Vaadin fits into microservice-based systems.
order: 50
---

# Microservices

Microservices is an architectual style that decomposes a system into a collection of _loosely coupled_ and _independently deployable_ services. Each microservice is centered around a specific business capability and is developed, deployed and scaled independently, typically by its own team. A microservice typically has its own database that is not shared with any other service.

Microservices interact over network calls and can therefore be built using different programming languages and frameworks, as long as the communication protocols (such as gRPC and JSON/REST/HTTP) are compatible. Because microservices can go down and up at any time, they have to be resilient by design. A service calling another service should remain operational even if the other service is unavailable.

You can read more about microservices at, for example, https://martinfowler.com/microservices/[martinFowler.com].

// TODO Add link to page about architectural styles once written

## Microservices and Vaadin

The Vaadin platform is not itself a platform for building microservices. However, you can build and deploy Vaadin apps for microservice environments. Since Vaadin apps are Spring Boot apps, they play nicely together with https://spring.io/projects/spring-cloud[Spring Cloud].

There are two primary use cases for Vaadin in a microservice environment: building _dedicated_ user interfaces, and building _aggregating_ user interfaces. You'll learn about these cases next. If your use case does not fall in any of these categories, chances are you need to use something else for your user user interface.

### Dedicated User Interfaces

Some microservices can have their own user interfaces. For example, if a microservice has been built for a particular department within a bigger organization, it makes sense that the user interface is also specific to that department. Since the microsevice is designed for internal use, it is not likely to require as much scaling as e.g. a public facing webshop. Thefore, it may make more sense to build the microservice as a Vaadin app, with its own Vaadin user interface. The service can still expose an API for other microservices to use.

Look at the following example:

image:images/microservices-dedicated.png[A diagram of a system with three separate microservices with dedicated user interfaces]

In this fictional organization, orders, invoicing and shipping are handled by separate department. Each department has their own microservice with a Vaadin UI specialized for their needs. The microservices are also communicating with each other through an event bus.

### Aggregating User Interfaces

In some cases, you may have to build a user interface for a specific group of users that need to interact with multiple microservices through some API. In this case, the user interface alone becomes a microservice itself, but without an API. The user interface aggreagtes multiple microservices into a holistic user experience, preventing the user from having to jump between multiple user interfaces in their daily work.

Look at the following example:

image:images/microservices-aggregating.png[A diagram of a system with three separate microservices that share the same user interface]

In this fictional organization, the warehose workers need accesss to both the product catalog, the inventory service and the shipping service. These microservices are all maintained by different teams, and are even built using completely different frameworks (Spring Boot, Node.JS and .NET). The microservices expose REST APIs for the user interface to use, while communicating with each other through an event bus.

The warehouse UI is a Vaadin app that provides not only the user interface itself, but also acts as its own _API gateway_. In other words, there is no need to set up a separate API gateway since the Vaadin app can communicate directly with the other microservices. This is effectively the _Backend for Frontend_ (BFF) pattern.

// TODO Is there a link to more information about BFF?

## Advantages

Microservices were not invented over night. Rather, they emerged in response to a particular set of problems that they are very good at solving. Here are some of the main benefits of building microservice-based systems:

### Targeted Scalability

You can scale specific microservices according to demand, which is beneficial if different parts of the system has varying loads. By only scaling up (adding more hardware resources) or out (deploying more instances) the parts that really need it, you can use the hardware resources more efficiently, thereby saving money.

### Flexibility in Technology

Since the microservices are decoupled and communicate over standardized network protocols, the teams can choose the best technology stack for their requirements. This also reduces the risk of vendor-lock in.

### Resilience

Well-designed microservices can handle failures gracefully, either by degrading functionality or by employing fallback mechanisms. Given the fact that they are also loosely coupled and independently deployable, the system as a whole becomes more resilient to disturbances. The failure of a single service does not take down the entire system.

### Continous Deployment

Teams can work on their own microservices at their own pace and deploy them as often as they like without affecting the rest of the system. Microservices can be developed in parallel and features can be deployed more quickly.

## Disadvantages

Microservices are really useful for solving a certain class of problems. For other problems, they are overkill or just not suitable at all. Here are some of the main drawbacks of building microservice-based systems:

### Increased Complexity

As the number of microservices increase, so does the number of moving parts. Getting these parts to interact in an efficient and consistent manner is not easy. Data integrity is harder to achieve when multiple services are involved in implementing the same business process, especially when any of these services can go down and come up at any time.

If you are not careful, you may end up with a distributed monolith that has none of the advantages of microservices but all the disadvantages. In the worst case, you may end up with a Distributed Ball of Mud, which is even worse than a http://www.laputan.org/mud/mud.html#BigBallOfMud[Big Ball of Mud].

### Technology Creep

Letting teams choose their own technology stacks was already listed as an advantage, but it can also be a disadvantage. Having too many technology stacks to keep track of can make it more difficult to move developers between teams, which is a risk for the organization. Furthermore, the overall environment - with its continous delivery chains and all - becomes more complicated the more technology stacks it needs to support.

### Communication Overhead

Microservices communicate over network calls, which are inherently slower than function calls. Furthermore, network calls are inherently less secure than function calls, which means more overhead for encryption, decryption, authentication, etc. If not managed properly, this leads to poor overall performance of the system.

### Testing and Debugging Challenges

A distributed system consisting of multiple processes is much more difficult to test and debug than a single process running on a single machine. The root cause of an issue observed in one microservice may actually be in a completely different microservice.

## When to Use

Microservices may be a good choice when:

* You have more than one team working on the system.
* Your system is providing more than one service to more than one group of users.
* You need to be able to redeploy parts of your system without affecting others.
* Different parts of the system have different loads, requiring different scaling.
* You know how to build microservices or already have a microservice environment up and running.

Before you start a new microservice-based project, you should seriously consider whether a <<monolith#,monolith>> would be sufficient to get the job done.
