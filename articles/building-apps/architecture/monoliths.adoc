---
title: Monoliths
description: TODO Describe me
order: 40
---

# Monoliths

In software engineering, a _monolithic application_ is a single, self-contained application. All system-components are running inside the same executable and communicate with each other over function calls. The application typically provides a single - but complete - service to its users.

Although a monolith often requires some supporting services like a database or an authentication provider, it is pretty much self sufficient. In its simplest case, a monolithic application is a single executable that runs on a single server.

Even though monoliths are packaged as a single executable, they can still be modular. _Modular monoliths_ introduce clear boundaries between the different parts of the application and define how these parts can communicate with each other. Some parts may not even know about the existence of other parts! A good way of building modular monoliths is to design using <<components#,system components>>.

## Advantages

In the time of <<microservices#,microservices>>, monoliths have received a bit of a bad reputation. However, that reputation is not entirely called for. There are, in fact, several advantages with monoliths compared to microservices.

### Simplicity

Monoliths, when done well, are easy to develop, test, debug and deploy. The components are contained inside a single codebase, often inside a single project in your IDE. You only need to test and debug a single executable. You don't have to set up a lot of supporting services in order to deploy the monlith: in many cases, the executable and a database is enough.

### Transactional Integrity

Since every thing happens inside the same executable, you don't have to worry about things like distributed transactions or sagas. In most cases, you can rely on good ol' ACID-transactions.

### Less Overhead

Most of the system components communicate over function calls rather than network calls. This often translates to better overall performance of the application.

// TODO List a few more advantages

## Disadvantages

As mentioned, monoliths have received a bit of a bad reputation, and some of it is in fact called for. There are several disadvantages with monoliths that need to be taken into account when deciding what kind of system architecture to choose.

### Scalability Challenges

It is possible to scale a monolith. You can scale both up (add more hardware resources) and out (deploy more instances of the monolith). However, you are always scaling the entire application. If only some parts of it actually require scaling, you may end up wasting resources that cost money.

You may also run into another type of scalability challenge: scaling the code. As the monolith grows and more features are added to it, increasing effort is needed to prevent the quality of the code from degrading. In the worst case, the monolith can degrade into an unmaintainable http://www.laputan.org/mud/mud.html#BigBallOfMud[Big Ball of Mud]. 

### Continous Deployment Challenges

You can use continous deployment with a monolith. However, even small changes require rebuilding and deploying the entire application. If you have not set up session replication and rolling updates, every redeployment means downtime for your users.

### Team Collaboration Challenges

A monolith should be owned by one team only. If you have more than one team working on the same application, you have to work hard to keep the teams aligned. The risk of conflicts in design, source control, release cadence, etc. increases.

// TODO List a few more disadvantages

## When to Use

*We belive that most business applications should, in fact, be monoliths.* If your application is going to provide a single service to a limited number of users in a limited geographical area, a monolith will do just fine.

Microservices come with many buzzwords, like endless scalability and improved resiliency. They sound really nice to have, but they come with a cost. Is your application worth that cost, or can the time and money be spent on something better? In many cases, you can achieve the qualities (like scalability, availability, performance) you need without switching to microservices. Choosing microservices just because everybody else is doing it is not a good idea.

// TODO Add link to quality aspects once written

That said, you can do some future profing by making your monolith modular. A carefully crafted, modular monolith is easier to split up into microservices in the future, should the need arise.
