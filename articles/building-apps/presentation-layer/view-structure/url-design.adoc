---
title: URL Design
description: TODO write description
order: 20
---

// Notes from Gerald:
//
// String IDs in URLs
// - is there maybe a more practical example, how to use NanoId? would you save it along the primary key in the DB? if not: how do you convert it forth and back, in a map? what happens with that map if the application restarts?


= URL Design

The <<composition#,previous>> page explained how to split this mock-up into UI components:

image::images/application.png[]

This page explains how to design the URL of the mock-up based on how a user is intended to navigate the view. The main focus is on deciding what _view state_ to store in the URL, as path or query parameters.

To understand why this is important, suppose you're working with an application, and want one of your colleagues to look at some part of it. You could ask them to open the application and scan it for something you want to show them. However, if the relevant state was stored in the URL, you could instead send that to them. The colleague would then only need to click the link to see the same view as you -- after authenticating.


== Path Parameters

Path parameters are part of the URL path: `/view/[parameter1]/[parameter2]`. Use path parameters for navigating to a specific view, or a sub-view within a view.

In the fictional application, the root path of the _Teams_ view is `/teams`. If you navigate to this path, you get this:

image::images/no-selection.png[]

The first path parameter is the ID of the team: `/teams/[teamId]`. For example, the team _Research and Development (R&D)_ could have a path like, `/teams/8zguABh6u`.

It's quite common to use incrementing long integers as database primary keys. If you use such a key in the URL, for example `/teams/1`, it's easy for an attacker to deduce that there may also be a `/teams/2`, a `/teams/3` and so on. Even if you've secured the application so that only authorized users can access regardless of whether they know the URL or not, the URL is exposing internal information. This information can be used to attack the application in other ways. Instead, use a random ID such as `/teams/8zguABh6u`. Internally, you can still use long incrementing integers for primary and foreign keys, as they're faster than strings.

The Teams view has three sub-views, visible as tabs: _Employees_; _Salaries_; and _Documents_. The selected tab is the second path parameter: `/teams/[teamId]/[tab]`. For example, the sub-views could have the following paths:

- Employees: `/teams/8zguABh6u/employees`
- Salaries: `/teams/8zguABh6u/salaries`
- Documents: `/teams/8zguABh6u/documents`

Because the Employees tab should be selected by default, the path `/teams/8zguABh6u` should be considered an alias of `/teams/8zguABh6u/employees`. If you navigate to either of these paths, you get this:

image::images/no-employee-selection.png[]

The Employees sub-view allows you to select an employee to view their details. This selection is the third path parameter and it's only valid when the Employees tab is selected: `/teams/[teamId]/employees/[employeeId]`. For example, _Cody Fisher_ could have the path `/teams/8zguABh6u/employees/zxPIVBqJ2`. If you navigate to this path, you end up with the state of the original mock-up:

image::images/application.png[]


== Query Parameters

Query parameters are added to the end of a URL after a question mark (i.e., the `?`). You can specify multiple query parameters by separating them with ampersands (i.e., `&`): `/view?param1=foo&param2=bar`. Use query parameters if you want to be able to share or bookmark a view while it's in a specific state. Such a state could, for example, be a particular sort order or filter.

You don't have to use query parameters unless there is a clear benefit to do so. Looking at the mock-up, the view is already quite usable without query parameters. It still has some candidates which you'll look at next, for the sake of demonstration.

The Teams view has a text field for filtering the list of teams. This is the first candidate for a query parameter: `/teams/8zguABh6u?search=foobar`

The Employees sub-view has a grid that can be sorted by clicking at the column headers. This is the second candidate for a query parameter: `/teams/8zguABh6u/employees/?orderEmployeesBy=firstName,lastName`

You can have query parameters and path parameters for both the view and the sub-view at the same time. For example, look at this URL: 

[source]
----
/teams/8zguABh6u/employees/zxPIVBqJ2?search=research&orderEmployeesBy=firstName,lastName
----

You can extract the following information:

- The current view is the Teams view.
- The team whose public ID is `8zguABh6u` is selected.
- The Employees sub-view is visible.
- The employee whose public ID is `zxPIVBqJ2` is selected.
- The team list is filtered using the search term `research`.
- The employee grid is sorted first by first name, then by last name.


== String IDs in URLs

The examples above used random strings as public IDs. When you generate a random ID, you should pay attention to its usability. Since the ID is public, people may want to copy and paste it, either on its own or as a part of the URL. That means the ID must be URL-friendly, short and easy to copy.

An easy way of generating random string IDs in Java is to use Universally Unique IDentifiers (UUID). Java has a [classname]`UUID` class in the [packagename]`java.util` package. You can use it to generate random UUIDs by calling [methodname]`UUID.randomUUID()`. However, there is a problem with using UUIDs as public IDs in URLs.

Try to select this UUID by double-clicking on it:

[source]
----
78f98876-b150-4e08-8d7e-41bb5e0f7e72
----

You probably selected only a part of the ID instead of the whole string. This is because of the hyphens. You can fix that by either removing the hyphens or replacing them with underscores. Try to select these IDs by double-clicking on them:

[source]
----
78f98876_b150_4e08_8d7e_41bb5e0f7e72
78f98876b1504e088d7e41bb5e0f7e72
----

You should now be able to select the whole string. However, the string is still quite long and when used as URL parameters, the URL becomes quite long too: 

[source]
----
https://myapp.example.com/teams/78f98876b1504e088d7e41bb5e0f7e72/employees/5191cfa1823e40858b0f0e10ce50c28e
----

This is not a user friendly URL. You can copy-paste it, but it's difficult to read. Telling it to somebody verbally is much more difficult.

A better alternative for public random string IDs is _NanoId_. NanoIds allow you to pick both the length and the alphabet. By default, the length is 21 characters and the character set allows numbers (0-9), letters (A-Z and a-z), and the hyphen and underscore (i.e., `-` and `_`).

If you use 9-character NanoIds generated from an character set consisting of only numbers, uppercase and lowercase letters, you'll get a URL like this:

[source]
----
https://myapp.example.com/teams/aftD6ZXp6/employees/m4wqAas1Q
----

This is shorter and more user friendly.

NanoId has been implemented in different programming languages, among others https://github.com/aventrix/jnanoid[Java] and https://github.com/ai/nanoid[JavaScript].


== Back Button Behavior

Once you're ready with the URL design, there's one more thing to consider: the browser's back button.

When you navigate to a URL in a web browser, a new entry is pushed to the browser's history stack. When you click the back button, the browser goes back one step in the history stack. You can continue to click the button until you reach the bottom of the stack.

When a user uses a web application, the application itself handles the navigation in response to the user's actions. For example, in the mock-up application, the user would not modify the URL to select a team or a tab. Rather, the user would click on the team and the tab. The application would then be responsible for modifying the URL.

When a web application updates the URL, it can do it in two ways: either by pushing new entries to the history stack; or by replacing the current entry in the history stack. This affects the behavior of the browser's back button.

Consider the following scenario: the user opens the application, selects a team, sorts the employee grid and then selects an employee. If every URL change was pushed to the history stack, the history stack would look like the following, sorted from oldest to newest:

- `/teams`
- `/teams?search=research`
- `/teams/aftD6ZXp6?search=research`
- `/teams/aftD6ZXp6?search=research&orderEmployeesBy=lastName`
- `/teams/aftD6ZXp6/employees/zxPIVBqJ2?search=research&orderEmployeesBy=lastName`

Given this stack, if the user then clicked once the back button, they would end up with a sorted employee grid without a selection. Another click would take the user to the same employee grid, but with its default sort order. A third click would deselect the team and show the search results. A final click would show the list of all teams, without any filters applied. This would not be what the user expected; it would be a bad user experience.

Since the search fields has no extra button, the query is executed as soon as the user stops typing. If the user is typing slowly, you may end up with entries like the following in the history stack:

- `/teams?search=re`
- `/teams?search=resea`
- `/teams?search=research`

If the user now clicked the back button, they would be confused. It would be an even worse user experience. 

A good general practice is to push new entries to the history stack whenever the path of the URL changes, and replace the current entry whenever query parameters change. With this behavior, the use case described earlier would result in the following history stack, sorted from oldest to newest:

- `/teams?search=research`
- `/teams/aftD6ZXp6?search=research&orderEmployeesBy=lastName`
- `/teams/aftD6ZXp6/employees/zxPIVBqJ2?search=research&orderEmployeesBy=lastName`

If the user clicked the back button now, they would end up with a sorted employee grid without a selection. Another click would deselect the team and show the search results.

As with all good practices, there may be exceptions. What's important here is to consider back button behavior when designing the view URL and be sure it makes sense.
