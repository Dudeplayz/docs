---
title: Configuration
description: Instructions on how to configure Observability Kit and what are the default settings.
order: 20
---

= Configuring Observability Kit

Instrumentation can be configured in the [filename]`agent.properties` file that's used with the Java agent.

== Service Configuration

The `service` attributes are used to differentiate traces from different services or applications which might have many instances running simultaneously, for example, horizontally scaled services.

The service attributes are as follows:

* `service.name` is an attribute that's used to distinguish a service by name.
+
The default value is `vaadin`.
This is the only attribute with a default value.
It's also the only one required.
* `service.namespace` helps to distinguish a group of services.
* `service.instance.id` helps to distinguish instances of the same service that exist at the same time.
+
This must be unique for each instance of the same `service.namespace`, `service.name` pair.
* `service.version` Semantic Versioning string of the service version.

The `service.name` attribute is configured using the `otel.service.name` property, either in the [filename]`agent.properties` configuration file, as a system property, or as environment variable.

[.example]
--

Add the following line to the [filename]`agent.properties` file:
[source,properties]
----
<source-info group="Configuration file"></source-info>
otel.service.name=myapp
----

Pass the `otel.service.name` system property when starting the Java process:
[source,terminal]
----
<source-info group="System property"></source-info>
java -Dotel.service.name="myapp" ...
----

Define the `OTEL_SERVICE_NAME` environment variable before starting the Java process:
[source,terminal]
----
<source-info group="Environment variable"></source-info>
# Linux / macOS
export OTEL_SERVICE_NAME="myapp"
# Windows
set OTEL_SERVICE_NAME="myapp"
----

--

Other service attributes are configured using the `otel.resource.attributes` property, either in the [filename]`agent.properties` configuration file, as a system property, or as environment variable.
Multiple attributes are separated by commas.

[.example]
--

Add the following line to the [filename]`agent.properties` file:
[source,properties]
----
<source-info group="Configuration file"></source-info>
otel.resource.attributes=service.namespace=myservices,service.instance.id=myapp-eu
----

Pass the `otel.resource.attributes` system property when starting the Java process:
[source,terminal]
----
<source-info group="System property"></source-info>
java -Dotel.resource.attributes="service.namespace=myservices,service.instance.id=myapp-eu" ...
----

Define the `OTEL_RESOURCE_ATTRIBUTES` environment variable before starting the Java process:
[source,terminal]
----
<source-info group="Environment variable"></source-info>
# Linux / macOS
export OTEL_RESOURCE_ATTRIBUTES="service.namespace=myservices,service.instance.id=myapp-eu"
# Windows
set OTEL_RESOURCE_ATTRIBUTES="service.namespace=myservices,service.instance.id=myapp-eu"
----

--

For more information about service configuration, see the https://opentelemetry.io/docs/reference/specification/resource/semantic_conventions/#service[OpenTelemetry documentation].

== Default OpenTelemetry Instrumentation

The custom distribution disables default OpenTelemetry instrumentation for Vaadin and servlets.

The default instrumentation is disabled because a single-page Vaadin application logging all requests wasn't helpful and generated plenty of data.
They were disabled to have control over which requests generate a trace.

The instrumentation modules that are disabled by default are:

* jetty
* servlet
* tomcat

To enable any of these, add the following line to the [filename]`agent.properties` file:
[source,properties]
----
otel.instrumentation.${instrumentationName}.enabled=true
----


== Frontend Observability Runtime Configuration

By default, frontend observability enables all out-of-the-box client-side instrumentation.
Observability Kit provides a way to programmatically enable, disable and tune the instrumentation at runtime.

This is done by implementing the [interfacename]`ObservabilityClientConfigurer` and applying the desired settings to the [interface]`ObservabilityClientConfiguration` instance provided to the [methodname]`configure` method.
The configuration is applied during UI initialization, meaning that the configurator logic can access the current [classname]`VaadinRequest` and the user details, if a security infrastructure has been configured for the project and the user is logged into the application.
This allows to fine tune the observability to single user granularity.

For example, the following implementation shows how to set up observability based on a mutable configuration tight to the current logged user.

.Example of ObservabilityClientConfigurer implementation
[source,java]
----
package org.example;

import java.security.Principal;

import org.example.UserObservabilityConfig;

import com.vaadin.flow.server.VaadinRequest;
import com.vaadin.observability.ObservabilityClientConfiguration;
import com.vaadin.observability.ObservabilityClientConfigurer;

public class UserBasedFrontendObservability implements ObservabilityClientConfigurer {

    @Override
    public void configure(ObservabilityClientConfiguration config) {
        VaadinRequest request = VaadinRequest.getCurrent();
        UserObservabilityConfig userSettings = fetchConfiguration(request.getUserPrincipal());
        if (userSettings != null && userSettings.isEnabled()) {
            config.setEnabled(true);
            config.setDocumentLoadEnabled(userSettings.isDocumentLoad());
            config.setUserInteractionEnabled(userSettings.isUserInteraction());
            config.setLongTaskEnabled(userSettings.isLongTask());
            config.setXMLHttpRequestEnabled(userSettings.isXmlHTTPRequest());
            config.setFrontendErrorEnabled(userSettings.isFrontendError());
        } else {
            config.setEnabled(false);
        }
    }

    // UserObservabilityConfig represent a simple DTO that carries user related information
    // used to tune ObservabilityClientConfiguration
    private UserObservabilityConfig fetchConfiguration(Principal user) {
        if (user != null) {
            // fetch the configuration for the given user from some storage
            // e.g. in-memory data structure, database table, properties file, ...
            return config;
        }
        // user not logged-in, return null or a default configuration
        return null;
    }

}
----

With the above implementation, the configuration can for example be fetched from a database table, allowing changes to be applied at runtime after a browser page reload.

The configurator is loaded through the Java ServiceLoader API, adding to [filename]`src/main/resources/META-INF/services/` the file [filename]`com.vaadin.observability.ObservabilityClientConfigurer` with the content being the fully qualified name of the configurator class. For this example, the content would be `org.example.UserBasedFrontendObservability`.

For details on observability client settings, consult the Javadocs of [interfacename]`ObservabilityClientConfiguration` interface.

.Load the configurator in a Spring project
[NOTE]
====
For Spring based project, the configurator can be loaded by exposing the implementation as a Spring managed [annotationname]`@Bean`, without the need to register the class for the ServiceLoader API.
====
